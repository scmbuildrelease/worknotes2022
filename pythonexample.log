class Node():
    def __init__(self, key, value):
        self.key, self.val=key, value
        self.prev=self.next=None

class LRUCache(object):
    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.cap=capacity
        self.cache={}
        self.right=Node(0,0)
        self.left=Node(0,0)
        self.left.next=self.right
        self.right.prev=self.left
         
    def remove(self, node):
        pre=node.prev
        nxt=node.next
        pre.next=nxt
        nxt.prev=pre
        
        
    def insert(self, node):
        pre,nxt=self.right.prev, self.right
        pre.next=nxt.prev=node
        node.next=nxt
        node.prev=pre
        
        
    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
       # print(key, self.cache[key].val)
        if key in self.cache:
            self.remove(self.cache[key])
            self.insert(self.cache[key])
            return self.cache[key].val
         
        return -1
        

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        
        if key in self.cache:
            self.remove(self.cache[key])
        self.cache[key]=Node(key, value)
        self.insert(self.cache[key])
        
        if len(self.cache) > self.cap:
            lru=self.left.next
            self.remove(lru)
            del self.cache[lru.key]
        
 
        
        

 


##class automation

#batching commandline.py

import sys
import random
import subprocess
def generateFiles(numFiles, nameFiles):
    for i in range(0,numFiles):
        postfix = str(i) + '.txt'
        postfixDir = str(i)
        subprocess.check_call(['mkdir','example' + postfixDir])
        temp = open(nameFiles + postfix, 'w')
        temp.write(str(random.randint(1,10)))
        temp.close()
        subprocess.check_call(['mv', nameFiles + postfix, 'example' + postfixDir])
    return

def main():
    print(sys.argv[0],sys.argv[1],sys.argv[2])
    numFiles = int(sys.argv[1])
    nameFiles = str(sys.argv[2])
    generateFiles(numFiles, nameFiles)

main()

##drag and drop
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
url = 'http://dhtmlgoodies.com/scripts/drag-drop-custom/demo-drag-drop-3.html'
driver = webdriver.Chrome()
driver.maximize_window()
driver.get(url)
source = driver.find_element_by_xpath('//*[@id="box3"]')
destination = driver.find_element_by_xpath('//*[@id="box103"]')
actions = ActionChains(driver)
actions.drag_and_drop(source, destination).perform()

##fileio
fileName = 'inputFile.txt'
f = open(fileName,'r')
output1 = "PassFile.txt"
output2 = "FailFile.txt"
passFile = open(output1,'w')
failFile = open(output2, 'w')
for line in f:
    line_split = line.split()
    if line_split[2] == "P":
        passFile.write(line)
    else:
        failFile.write(line)
passFile.close()
failFile.close()

##interaction
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
url = 'https://www.google.com/earth/'
driver = webdriver.Chrome()
driver.get(url)
wait = WebDriverWait(driver, 10)
launchEarthButton = wait.until(EC.element_to_be_clickable((By.XPATH,'/html/body/header/div/nav[1]/ul[2]/li[2]/a/span/span')))
launchEarthButton.click()

##orgnize directory
import os
from pathlib import Path
SUBDIRECTORIES = {
    "DOCUMENTS": ['.pdf','.rtf','.txt'],
    "AUDIO":['.m4a','.m4b','.mp3'],
    "VIDEOS": ['.mov','.avi','.mp4'],
    "IMAGES": ['.jpg','.jpeg','.png']
}
def pickDirectory(value):
    for category, suffixes in SUBDIRECTORIES.items():
        for suffix in suffixes:
            if suffix == value:
                return category
    return 'MISC' #If filetype doesn't exist in our dictionary

def organizeDirectory():
    for item in os.scandir():
        if item.is_dir():
            continue
        filePath = Path(item)
        filetype = filePath.suffix.lower()
        directory = pickDirectory(filetype)
        directoryPath = Path(directory)
        if directoryPath.is_dir() != True:
            directoryPath.mkdir()
        filePath.rename(directoryPath.joinpath(filePath))

organizeDirectory()

##scrape
import requests
from bs4 import BeautifulSoup
url = 'http://quotes.toscrape.com/'
response = requests.get(url)
soup = BeautifulSoup(response.text,'lxml')
quotes = soup.find_all("span", class_="text")
authors = soup.find_all("small", class_="author")
tags = soup.find_all("div", class_="tags")
for i in range(0,len(quotes)):
    print(quotes[i].text)
    print(authors[i].text)
    quoteTags = tags[i].find_all('a',class_='tag')
    for quoteTag in quoteTags:
        print(quoteTag.text)
        
        
## scrapge pages

from bs4 import BeautifulSoup
import requests
url = 'https://scrapingclub.com/exercise/list_basic/'
count = 1
response = requests.get(url)
soup = BeautifulSoup(response.text, 'lxml')
items = soup.find_all('div', class_='col-lg-4 col-md-6 mb-4')
for i in items:
    itemName = i.find('h4', class_='card-title').text.strip('\n')
    itemPrice = i.find('h5').text
    print('%s) Price: %s , Item Name: %s' % (count, itemPrice, itemName))
    count = count + 1
pagination = soup.find('ul', class_='pagination')
pages = pagination.find_all('a', class_='page-link')
urls = []
for page in pages:
    pageNum = int(page.text) if page.text.isdigit() else None
    if pageNum != None:
        link = page.get('href')
        urls.append(link)
for i in urls:
    response = requests.get(url + i)
    soup = BeautifulSoup(response.text, 'lxml')
    items = soup.find_all('div', class_='col-lg-4 col-md-6 mb-4')
    for i in items:
        itemName = i.find('h4', class_='card-title').text.strip('\n')
        itemPrice = i.find('h5').text
        print('%s) Price: %s , Item Name: %s' % (count, itemPrice, itemName))
        count = count + 1
  
  
  ####
  
  import os
from bs4 import BeautifulSoup, Doctype

directory = '/home/brian/Code/sof'
for root, dirnames, filenames in os.walk(directory):
    for filename in filenames:
        if filename.endswith('.html'):
            fname = os.path.join(root, filename)
            print('Filename: {}'.format(fname))
            with open(fname) as handle:
                soup = BeautifulSoup(handle.read(), 'html.parser')
                for item in soup.contents:
                    if isinstance(item, Doctype):
                        print('Doctype: {}'.format(item))
                        break
       
  ## web browser
  
  from selenium import webdriver
url = 'https://www.seleniumeasy.com/test/basic-first-form-demo.html'
driver = webdriver.Chrome()
driver.get(url)
messageField = driver.find_element_by_xpath('//*[@id="user-message"]')
messageField.send_keys("Hello World")
showMessageButton = driver.find_element_by_xpath('//*[@id="get-input"]/button')
showMessageButton.click()
additionField1 = driver.find_element_by_xpath('//*[@id="sum1"]')
additionField1.send_keys('10')
additionField2 = driver.find_element_by_xpath('//*[@id="sum2"]')
additionField2.send_keys('12')
getTotalButton = driver.find_element_by_xpath('//*[@id="gettotal"]/button')
getTotalButton.click()

##class algo
# prime
def get_prime_factors(N):
    factors = list()
    divisor = 2
    while(divisor <= N):
        if (N % divisor) == 0:
            factors.append(divisor)
            N = N//divisor
            print(divisor)
        else:
            divisor += 1
    return factors
    
if __name__ == '__main__':
    print(get_prime_factors(260))
    print(get_prime_factors(13))
    
##palindrome

import re

def is_palindrome(phrase):
    forwards = ''.join(re.findall(r'[a-z]+', phrase.lower()))
    backwards = forwards[::-1]
    return forwards == backwards

if __name__ == '__main__':
    print(is_palindrome('hello world'))
    print(is_palindrome("Go hang a salami, I'm a lasagna hog."))
    
    
#3
def sort_words(input):
    return ' '.join(sorted(input.split(), key = str.casefold))
 
if __name__ == '__main__':
    print(sort_words('banana ORANGE apple'))
    
#$4

def index_all(search_list, item):
    indices = list()
    for i in range(len(search_list)):
        if search_list[i] == item:
            indices.append([i])
        elif isinstance(search_list[i], list):
            for index in index_all(search_list[i], item):
                indices.append([i]+index)
    return indices

if __name__ == '__main__':    
    example = [[[1, 2, 3], 2, [1, 3]], [1, 2, 3]]
    print(index_all(example, 2))
    print(index_all(example, [1, 2, 3]))
    
    
    
##5
import time
import random

def waiting_game():
    target = random.randint(2,4) # target seconds to wait
    print('\nYour target time is {} seconds'.format(target))

    input(' ---Press Enter to Begin--- ')
    start = time.perf_counter()
    print(start)
    
    input('\n...Press Enter again after {} seconds...'.format(target))
    elapsed = time.perf_counter() - start
    
    print('\nElapsed time: {0:.3f} seconds'.format(elapsed))
    if elapsed == target:

        print('(Unbelievable! Perfect timing!)')
    elif elapsed < target:
        print('({0:.3f} seconds too fast)'.format(target - elapsed))
    else:
        print('({0:.3f} seconds too slow)'.format(elapsed - target))
    
if __name__ == '__main__':
    waiting_game()
    
  ##6
  
  import pickle

def save_dict(dict_to_save, file_path):
    with open(file_path, 'wb') as file:
        pickle.dump(dict_to_save, file)
    
def load_dict(file_path):
    with open(file_path, 'rb') as file:
        return pickle.load(file)

if __name__ == '__main__':
    test_dict = {1: 'a', 2: 'b', 3: 'c'}
    save_dict(test_dict, 'test_dict.pickle')
    recovered = load_dict('test_dict.pickle')
    print(recovered)
    
    
    
    ##7
    import sched
import time
import winsound as ws

def set_alarm(alarm_time, wav_file, message):
    s = sched.scheduler(time.time, time.sleep)
    s.enterabs(alarm_time, 1, print, argument=(message,))
    s.enterabs(alarm_time, 1, ws.PlaySound, argument=(wav_file, ws.SND_FILENAME))
    print('Alarm set for', time.asctime(time.localtime(alarm_time)))
    s.run()

if __name__ == '__main__':    
    set_alarm(time.time()+1, 'alarm.wav', 'Wake up!')
    
    #8
    import smtplib

SENDER_EMAIL = 'YOUR_EMAIL@EMAIL.COM' # replace with your email address
SENDER_PASSWORD = 'YOUR_PASSWORD'     # replace with your email password

def send_email(receiver_email, subject, body):
    message = 'Subject: {}\n\n{}'.format(subject, body)
    with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
        server.login(SENDER_EMAIL, SENDER_PASSWORD)
        server.sendmail(SENDER_EMAIL, receiver_email, message)

if __name__ == '__main__':
    # replace receiver email address
    send_email('RECEIVER@EMAIL.COM', 'Notification', 'Everything is awesome!')
    
    ##9
    
    from random import randint
from collections import Counter

def roll_dice(*dice, num_trials=1_000_000):  
    counts = Counter()
    for roll in range(num_trials):
        counts[sum((randint(1,sides) for sides in dice))] += 1
    
    print('\nOUTCOME\tPROBABILITY')
    for outcome in range(len(dice), sum(dice)+1):
        print('{}\t{:0.2f}%'.format(outcome, counts[outcome]*100/num_trials))
        
if __name__ == '__main__':
    roll_dice(4,6,6)
    roll_dice(4,6,6,20)
    
    #10
    
    import re
import collections

def count_words(path):
    with open(path, encoding='utf-8') as file:
        all_words = re.findall(r"[0-9a-zA-Z-']+", file.read())
        all_words = [word.upper() for word in all_words]
        print('\nTotal Words:', len(all_words))
        
        word_counts = collections.Counter(all_words)
        
        print('\nTop 20 Words:')
        for word in word_counts.most_common(20):
            print(word[0], '\t', word[1])
            
if __name__ == '__main__':
    count_words('shakespeare.txt')
    
    ##11
    
    import secrets

def generate_passphrase(num_words):
    with open('diceware.wordlist.asc', 'r') as file:    
        lines = file.readlines()[2:8]
        word_list = [line.split()[1] for line in lines]
        print(lines)
        print(word_list)

    words = [secrets.choice(word_list) for i in range(num_words)]
   # print(words)
    return ' '.join(words)
    
if __name__ == '__main__':
    print(generate_passphrase(4))
    #print(generate_passphrase(7))
    
    ##12
    
    import csv
def merge_csv(csv_list, output_path):
    # build list with all fieldnames
    fieldnames = list()
    for file in csv_list:
        with open(file, 'r') as input_csv:
            fn = csv.DictReader(input_csv).fieldnames
            fieldnames.extend(x for x in fn if x not in fieldnames)
    # write data to output file based on field names
    with open(output_path, 'w', newline='') as output_csv:
        writer = csv.DictWriter(output_csv, fieldnames=fieldnames)
        writer.writeheader()
        for file in csv_list:
            with open(file, 'r') as input_csv:
                reader = csv.DictReader(input_csv)
                for row in reader:
                    writer.writerow(row)
if __name__ == '__main__':
    merge_csv(['class1.csv', 'class2.csv'], 'all_students.csv')
    
    ##13
    
 from itertools import product
def solve_sudoku(puzzle):
    for (row, col) in product(range(0,9), repeat=2):
        if puzzle[row][col] == 0: # find an unassigned cell
            for num in range(1,10):
                allowed = True # check if num is allowed in row/col/box
                for i in range(0,9):
                    if (puzzle[i][col ] == num) or (puzzle[row][i] == num):
                        allowed = False; break # not allowed in row or col
                for (i, j) in product(range(0,3), repeat=2):
                    if puzzle[row-row%3+i][col-col%3+j] == num:
                        allowed = False; break # not allowed in box
                if allowed:       
                    puzzle[row][col] = num
                    if trial := solve_sudoku(puzzle):
                        return trial
                    else:
                        puzzle[row][col] = 0
            return False # could not place a number in this cell
    return puzzle
def print_sudoku(puzzle):
    # replace zeroes with dashes
    puzzle = [['*' if num == 0 else num for num in row] for row in puzzle]
    print()
    for row in range(0,9):
        if ((row % 3 == 0) and (row != 0)):
            print('-'*33) # draw horizontal line
        for col in range(0,9):
            if ((col % 3 == 0) and (col != 0)):
                print(' | ', end='') # draw vertical line
            print('', puzzle[row][col], '', end='')
        print()
    print()
if __name__ == '__main__':
    puzzle = [[5,3,0,0,7,0,0,0,0],
              [6,0,0,1,9,5,0,0,0],
              [0,9,8,0,0,0,0,6,0],
              [8,0,0,0,6,0,0,0,3],
              [4,0,0,8,0,3,0,0,1],
              [7,0,0,0,2,0,0,0,6],
              [0,6,0,0,0,0,2,8,0],
              [0,0,0,4,1,9,0,0,5],
              [0,0,0,0,8,0,0,7,9]]
    print_sudoku(puzzle)
    solution = solve_sudoku(puzzle)
    print_sudoku(solution)
    
    ##14
    import os
from zipfile import ZipFile
def zip_all(search_dir, extension_list, output_path):
    with ZipFile(output_path, 'w') as output_zip:
        for root, dirs, files in os.walk(search_dir):
            rel_path = os.path.relpath(root, search_dir)
            for file in files:
                name, ext = os.path.splitext(file)
                if ext.lower() in extension_list:
                    output_zip.write(os.path.join(root, file),
                                     arcname=os.path.join(rel_path, file))
if __name__ == '__main__':
    zip_all('.\\my_stuff', ['.jpg','.txt'], 'my_stuff.zip')
    
    ##15
    
    import os
import re
import urllib.parse
import urllib.request
def download_files(first_url, output_dir):
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)
    url_head, url_tail = os.path.split(first_url)
    first_index = re.findall(r'[0-9]+', url_tail)[-1]
    index_count, error_count = 0, 0
    while(error_count < 5):
        next_index = str(int(first_index) + index_count)
        if first_index[0] == '0': # zero padded
            next_index = '0' * (len(first_index) - len(next_index)) + next_index
        next_url = urllib.parse.urljoin(url_head, re.sub(first_index, next_index, url_tail))
        try:
            output_file = os.path.join(output_dir, os.path.basename(next_url))
            urllib.request.urlretrieve(next_url, output_file)
            print('Successfully downloaded {}'.format(os.path.basename(next_url)))
        except IOError:
            print('Could not retrieve {}'.format(next_url))
            error_count += 1
        index_count += 1
if __name__ == '__main__':
    download_files('http://123.xx.net/image001.jpg', '.\\images')
    
    ##KMP
    
    
  def slowsearch(fullstr, substr):
    f=len(fullstr)
    s=len(substr)
    i=j=k=0
    while i<f and j<s :
        if fullstr[i]==substr[j]:
            i+=1
            j+=1
        else:
            k+=1
            i=k
            j=0
    if j==s:
        return True
    else:
        return False

def helper(substr): ## [0,0,1,2,0]
    lstr=[0 for _ in range(len(substr))]
    j=0
    i=1
    while i <len(substr):
        if substr[j]==substr[i]:
            lstr[i]=j+1
            j+=1
            i+=1
        else:
            if j!=0:
                j=lstr[j-1] ## a a b a b
            else:
                lstr[i]=0  ##abcabc
                i+=1
    print(lstr)
    return lstr

def kmp(fullstr,substr):
    lps=helper(substr)
    i=j=0
    f=len(fullstr)
    s=len(substr)
    while i<f and j<s:
        if fullstr[i]==substr[j]:
            i+=1
            j+=1
        else:
            if j!=0: j=lps[j-1]
            else: i+=1
    if j==s: return True
    else: return False

fullstr1 = "abcxabcdabcdabcyooppoopp"
substr1 = "abcdabcy"
fullstr=list(fullstr1)
substr=list(substr1)
xx=kmp(fullstr,substr)
print(xx)

    
    
#ISBN

import re
##import sys

# `regex` checks for ISBN-10 or ISBN-13 format
regex = re.compile("^(?:ISBN(?:-1[03])?:? )?(?=[-0-9 ]{17}$|[-0-9X ]{13}$|[0-9X]{10}$)(?:97[89][- ]?)?[0-9]{1,"
                   "5}[- ]?(?:[0-9]+[- ]?){2}[0-9X]$")

subject = "978-3-16-148410-0"   #sys.argv[1]  978-3-16-148410-0

if regex.search(subject):
  # Remove non ISBN digits, then split into an array
  chars = re.sub("[^0-9X]", "", subject).split("")
  # Remove the final ISBN digit from `chars`, and assign it to `last`
  last  = chars.pop()

  if len(chars) == 9:
    # Compute the ISBN-10 check digit
    val = sum((x + 2) * int(y) for x,y in enumerate(reversed(chars)))
    check = 11 - (val % 11)
    if check == 10:
      check = "X"
    elif check == 11:
      check = "0"
  else:
    # Compute the ISBN-13 check digit
    val = sum((x % 2 * 2 + 1) * int(y) for x,y in enumerate(chars))
    check = 10 - (val % 10)
    if check == 10:
      check = "0"

  if (str(check) == last):
    print("Valid ISBN")
  else:
    print("Invalid ISBN check digit")
else:
  print("Invalid ISBN")
  
  ##ISBN
  
  import re

isbn="232323232X"    #"978-3-16-148410-0"
isbn = isbn.replace("-", "").replace(" ", "").upper();
match = re.search(r'^(\d{9})(\d|X)$', isbn)
if not match:
    print("False")

digits = match.group(1)
check_digit = 10 if match.group(2) == 'X' else int(match.group(2))

result = sum((i + 1) * int(digit) for i, digit in enumerate(digits))
if (result % 11) == check_digit:
    print("good")
else:
    print("nooo")

######
## PYTHON BASIC

#
# Example file for working with classes
#


class myClass():
    def method1(self):
        print("myClass method1")

    def method2(self, someString):
        print("myClass method2: " + someString)


class anotherClass(myClass):
    def method2(self):
        print("anotherClass method2")

    def method1(self):
        myClass.method1(self)
        print("anotherClass method1")


def main():
    c = myClass()
    c.method1()
    c.method2("This is a string")
    c2 = anotherClass()
    c2.method1()


if __name__ == "__main__":
    main()

##HARDWARE
#import commands
#https://docs.python.org/2/library/commands.html
import subprocess
cmd = "/usr/sbin/system_profiler SPHardwareDataType | fgrep 'Serial' | awk '{print $NF}'"
(status, output) = subprocess.getstatusoutput(cmd)
print(status, output)

######CALENDAR
#
# Example file for working with Calendars
#

import calendar

# create a plain text calendar
c = calendar.TextCalendar(calendar.SUNDAY)
str = c.formatmonth(2017, 1, 0, 0)
print (str)

# create an HTML formatted calendar
hc = calendar.HTMLCalendar(calendar.SUNDAY)
str = hc.formatmonth(2017, 1)
print (str)

# loop over the days of a month
# zeroes mean that the day of the week is in an overlapping month
for i in c.itermonthdays(2017, 8):
  print (i)
  
# The Calendar module provides useful utilities for the given locale,
# such as the names of days and months in both full and abbreviated forms
for name in calendar.month_name:
  print (name)

for day in calendar.day_name:
  print (day)

# Calculate days based on a rule: For example, consider
# a team meeting on the first Friday of every month.
# To figure out what days that would be for each month,
# we can use this script:
print ("Team meetings will be on:")
for m in range(1,13):
  # returns an array of weeks that represent the month
  cal = calendar.monthcalendar(2017, m)
  # The first Friday has to be within the first two weeks
  weekone = cal[0]
  weektwo = cal[1]
   
  if weekone[calendar.FRIDAY] != 0:
    meetday = weekone[calendar.FRIDAY]
  else:
    # if the first friday isn't in the first week, it must be in the second
    meetday = weektwo[calendar.FRIDAY]
      
  print ("%10s %2d" % (calendar.month_name[m], meetday))

##DATE
#
# Example file for working with date information
#

from datetime import date
from datetime import time
from datetime import datetime

def main():
  ## DATE OBJECTS
  # Get today's date from the simple today() method from the date class
  today = date.today()
  print ("Today's date is ", today)
  
  # print out the date's individual components
  print ("Date Components: ", today.day, today.month, today.year)
  
  # retrieve today's weekday (0=Monday, 6=Sunday)
  print ("Today's Weekday #: ", today.weekday())
  days = ["monday","tuesday","wednesday","thursday","friday","saturday","sunday"]
  print ("Which is a " + days[today.weekday()])
  
  ## DATETIME OBJECTS
  # Get today's date from the datetime class
  today = datetime.now()
  print  ("The current date and time is ", today)
  
  # Get the current time
  t = datetime.time(datetime.now())
  print ("The current time is ", t)
  
  
if __name__ == "__main__":
  main();
  
  
  ####
# Example file for formatting time and date output
#

from datetime import datetime

def main():
  # Times and dates can be formatted using a set of predefined string
  # control codes 
  now = datetime.now() # get the current date and time
  
  #### Date Formatting ####
  
  # %y/%Y - Year, %a/%A - weekday, %b/%B - month, %d - day of month
  print (now.strftime("The current year is: %Y")) # full year with century
  print (now.strftime("%a, %d %B, %y")) # abbreviated day, num, full month, abbreviated year
  
  # %c - locale's date and time, %x - locale's date, %X - locale's time
  print (now.strftime("Locale date and time: %c"))
  print (now.strftime("Locale date: %x"))
  print (now.strftime("Locale time: %X"))
  
  #### Time Formatting ####
  
  # %I/%H - 12/24 Hour, %M - minute, %S - second, %p - locale's AM/PM
  print (now.strftime("Current time: %I:%M:%S %p")) # 12-Hour:Minute:Second:AM
  print (now.strftime("24-hour time: %H:%M")) # 24-Hour:Minute


if __name__ == "__main__":
  main();


#
# Example file for working with timedelta objects
#

from datetime import date
from datetime import time
from datetime import datetime
from datetime import timedelta

# construct a basic timedelta and print it
print (timedelta(days=365, hours=5, minutes=1))

# print today's date
now = datetime.now()
print ("today is: " + str(now))

# print today's date one year from now
print ("one year from now it will be: " + str(now + timedelta(days=365)))

# create a timedelta that uses more than one argument
print ("in two weeks and 3 days it will be: " + str(now + timedelta(weeks=2, days=3)))

# calculate the date 1 week ago, formatted as a string
t = datetime.now() - timedelta(weeks=1)
s = t.strftime("%A %B %d, %Y")
print ("one week ago it was " + s)

### How many days until April Fools' Day?

today = date.today()  # get today's date
afd = date(today.year, 4, 1)  # get April Fool's for the same year
# use date comparison to see if April Fool's has already gone for this year
# if it has, use the replace() function to get the date for next year
if afd < today:
  print ("April Fool's day already went by %d days ago" % ((today-afd).days))
  afd = afd.replace(year=today.year + 1)  # if so, get the date for next year

# Now calculate the amount of time until April Fool's Day  
time_to_afd = afd - today
print ("It's just", time_to_afd.days, "days until next April Fools' Day!")



#
# Read and write files using the built-in Python file methods
#

def main():  
  # Open a file for writing and create it if it doesn't exist
  f = open("textfile.txt","w+")
  
  # Open the file for appending text to the end
  # f = open("textfile.txt","a+")

  # write some lines of data to the file
  for i in range(10):
    f.write("This is line %d\r\n" % (i+1))
  
  # close the file when done
  f.close()
  
  # Open the file back up and read the contents
  f = open("textfile.txt","r")
  if f.mode == 'r': # check to make sure that the file was opened
    # use the read() function to read the entire file
    # contents = f.read()
    # print (contents)
    
    fl = f.readlines() # readlines reads the individual lines into a list
    for x in fl:
      print (x)
    
if __name__ == "__main__":
  main()

#
# Example file for working with os.path module
#

import os
from os import path
import datetime
from datetime import date, time, timedelta
import time

def main():
  # Print the name of the OS
  print (os.name)
  
  # Check for item existence and type
  print ("Item exists: " + str(path.exists("textfile.txt")))
  print ("Item is a file: " + str(path.isfile("textfile.txt")))
  print ("Item is a directory: " + str(path.isdir("textfile.txt")))
  
  # Work with file paths
  print ("Item's path: " + str(path.realpath("textfile.txt")))
  print ("Item's path and name: " + str(path.split(path.realpath("textfile.txt"))))
  
  # Get the modification time
  t = time.ctime(path.getmtime("textfile.txt"))
  print (t)
  print (datetime.datetime.fromtimestamp(path.getmtime("textfile.txt")))
  
  # Calculate how long ago the item was modified
  td= datetime.datetime.now() - datetime.datetime.fromtimestamp(path.getmtime("textfile.txt"))
  print ("It has been " + str(td) + " since the file was modified")
  print ("Or, " + str(td.total_seconds()) + " seconds")

if __name__ == "__main__":
  main()


#
# Example file for working with filesystem shell methods
#
import os
from os import path
import shutil
from shutil import make_archive
from zipfile import ZipFile

def main():
  # make a duplicate of an existing file
  if path.exists("textfile.txt"):
    # get the path to the file in the current directory
    src = path.realpath("textfile.txt");
        
    # # let's make a backup copy by appending "bak" to the name
    dst = src + ".bak"
    # # now use the shell to make a copy of the file
    shutil.copy(src,dst)
    
    # # copy over the permissions, modification times, and other info
    shutil.copystat(src, dst)
    
    # # rename the original file
    os.rename("textfile.txt", "newfile.txt")
    
    # now put things into a ZIP archive
    root_dir,tail = path.split(src)
    shutil.make_archive("archive", "zip", root_dir)

    # more fine-grained control over ZIP files
    with ZipFile("testzip.zip","w") as newzip:
      newzip.write("newfile.txt")
      newzip.write("textfile.txt.bak")
      
if __name__ == "__main__":
  main()



# 
# Example file for parsing and processing HTML
#

# import the HTMLParser module
# in Python 3 you need to import from html.parser
from html.parser import HTMLParser

metacount = 0

# create a subclass of HTMLParser and override the handler methods
class MyHTMLParser(HTMLParser):
  # function to handle an opening tag in the doc
  # this will be called when the closing ">" of the tag is reached
  def handle_starttag(self, tag, attrs):
    global metacount
    if tag == "meta":
      metacount += 1

    print ("Encountered a start tag:", tag)
    pos = self.getpos() # returns a tuple indication line and character
    print ("\tAt line: ", pos[0], " position ", pos[1])

    if attrs.__len__() > 0:
      print ("\tAttributes:")
      for a in attrs:
        print ("\t", a[0],"=",a[1])
      
  # function to handle the ending tag
  def handle_endtag(self, tag):
    print ("Encountered an end tag:", tag)
    pos = self.getpos()
    print ("\tAt line: ", pos[0], " position ", pos[1])
    
  # function to handle character and text data (tag contents)
  def handle_data(self, data):
    if (data.isspace()):
      return
    print ("Encountered some text data:", data)
    pos = self.getpos()
    print ("\tAt line: ", pos[0], " position ", pos[1])
  
  # function to handle the processing of HTML comments
  def handle_comment(self, data):
    print ("Encountered comment:", data)
    pos = self.getpos()
    print ("\tAt line: ", pos[0], " position ", pos[1])

def main():
  # instantiate the parser and feed it some HTML
  parser = MyHTMLParser()
    
  # open the sample HTML file and read it
  f = open("samplehtml.html")
  if f.mode == "r":
    contents = f.read() # read the entire file
    parser.feed(contents)
  
  print ("%d meta tags encountered" % metacount)

if __name__ == "__main__":
  main();
  
  
  
  # 
# Example file for retrieving data from the internet
#
import urllib.request # instead of urllib2 like in Python 2.7

def main():
  # open a connection to a URL using urllib2
  webUrl = urllib.request.urlopen("http://www.google.com")
  
  # get the result code and print it
  print ("result code: " + str(webUrl.getcode()))
  
  # read the data from the URL and print it
  data = webUrl.read()
  print (data)

if __name__ == "__main__":
  main()


#
# Example file for parsing and processing JSON
#

import urllib.request  # instead of urllib2 like in Python 2.7
import json


def printResults(data):
    # Use the json module to load the string data into a dictionary
    theJSON = json.loads(data)

    # now we can access the contents of the JSON like any other Python object
    if "title" in theJSON["metadata"]:
        print(theJSON["metadata"]["title"])

    # output the number of events, plus the magnitude and each event name
    count = theJSON["metadata"]["count"]
    print(str(count) + " events recorded")

    # for each event, print the place where it occurred
    for i in theJSON["features"]:
        print(i["properties"]["place"])
    print("--------------\n")

    # print the events that only have a magnitude greater than 4
    for i in theJSON["features"]:
        if i["properties"]["mag"] >= 4.0:
            print("%2.1f" % i["properties"]["mag"], i["properties"]["place"])
    print("--------------\n")

    # print only the events where at least 1 person reported feeling something
    print("\n\nEvents that were felt:")
    for i in theJSON["features"]:
        feltReports = i["properties"]["felt"]
        if (feltReports != None):
            if (feltReports > 0):
                print("%2.1f" % i["properties"]["mag"], i["properties"]
                      ["place"], " reported " + str(feltReports) + " times")


def main():
    # define a variable to hold the source URL
    # In this case we'll use the free data feed from the USGS
    # This feed lists all earthquakes for the last day larger than Mag 2.5
    urlData = "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_day.geojson"

    # Open the URL and read the data
    webUrl = urllib.request.urlopen(urlData)
    print("result code: " + str(webUrl.getcode()))
    if (webUrl.getcode() == 200):
        data = webUrl.read().decode("utf-8")
        # print out our customized results
        printResults(data)
    else:
        print("Received an error from server, cannot retrieve results " +
              str(webUrl.getcode()))


if __name__ == "__main__":
    main()


class Stack(object):
    def __init__(self):
        self._stack=list()
    def push(self,i):
        self._stack.append(i)
    def pop(self):
        return self._stack.pop()
    def peek(self):
        return None if self.empty() else self._stack[-1]
    def empty(self):
        return len(self._stack)==0
class MinStack(Stack):
    def __init__(self):

        self._stack=list()
        self._stackmin=list()
    def push(self,i):
        if (not self._stackmin) or (i < self._stackmin[-1]):
            self._stackmin.append(i)
        else:
            self._stackmin.append(self._stackmin[-1])
        self._stack.append(i)

    def pop(self):
        if self._stack:
            self._stack.pop()
        if self._stackmin:
            return self._stackmin.pop()
        else:
            return None

    def peek(self):
        return None if self.empty() else self._stack[-1]
    def empty(self):
        return len(self._stackmin)==0

    def min(self):
        if self._stackmin:
            return self._stackmin[-1]
        else:
            return None

ms=MinStack()
ms.push(5)
assert ms.min()==5
ms.push(1)
ms.push(3)
assert ms.min()==1
assert ms.pop()==1
assert ms.min()==1
assert ms.pop()==1
assert ms.min()==5


class MinStack(Stack):
    def __init__(self):
        #super().__init__()
        Stack.__init__(self)
        self._stackmin=list()
        
 class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year


class Stack(object):
    def __init__(self):
        self._stack=list()
    def push(self,i):
        self._stack.append(i)
    def pop(self):
        return self._stack.pop()
    def peek(self):
        return None if self.empty() else self._stack[-1]
    def empty(self):
        return len(self._stack)==0
class MinStack(Stack):
    def __init__(self):
        self._stackmin=list()
    def push(self,i):  ##513
        if (not self._stackmin ) or (i <= self._stackmin[-1][1]) :
            self._stackmin.append([i,i])
        else:
            tmp=self._stackmin[-1][1]
            self._stackmin.append([i,tmp])

    def pop(self):
        if self._stackmin:
            return self._stackmin.pop()[0]
        else:
            return None

    def peek(self):
        return None if self.empty() else self._stackmin[-1][0]
    def empty(self):
        #return super().empty()
        return len(self._stackmin)==0

    def min(self):
        if self._stackmin:
            return self._stackmin[-1][1]
        else:
            return None

ms=MinStack()
ms.push(5)
assert ms.min()==5
assert ms.peek()==5
ms.push(1)
ms.push(3)
print(ms._stackmin)
assert ms.min()==1
assert ms.pop()==3
assert ms.min()==1
assert ms.pop()==1
assert ms.min()==5












    
    
    
    
    
    
    
    
    
    
    
    
    



















