   
    minprice=float("inf")
    for 2. Add Two Numbers, since the sum is the new number ,should create a new node, for remove duplicated node
   since it is already be the node and val, we do not need to create new one and just set the next links.
   
        dummy = ListNode(0,head)
        pred = dummy  
        pred.next = head.next
        return dummy.next
        
        result=ListNode(0)
        res=result
        res.next=ListNode(summ)
        res=res.next
        
   
   forwards = ''.join(re.findall(r'[a-z]+', phrase.lower()))
    backwards = forwards[::-1]
    
    There are two distincts types of 'time', in this context: absolute time and relative time.

Absolute time is the 'real-world time', which is returned by time.time() and which we are all used to deal with. It is usually measured from a fixed point in time in the past (e.g. the UNIX epoch of 00:00:00 UTC on 01/01/1970) at a resolution of at least 1 second. Modern systems usually provide milli- or micro-second resolution. It is maintained by the dedicated hardware on most computers, the RTC (real-time clock) circuit is normally battery powered so the system keeps track of real time between power ups. This 'real-world time' is also subject to modifications based on your location (time-zones) and season (daylight savings) or expressed as an offset from UTC (also known as GMT or Zulu time).

Secondly, there is relative time, which is returned by time.perf_counter and time.process_time. This type of time has no defined relationship to real-world time, in the sense that the relationship is system and implementation specific. It can be used only to measure time intervals, i.e. a unit-less value which is proportional to the time elapsed between two instants. This is mainly used to evaluate relative performance (e.g. whether this version of code runs faster than that version of code).

On modern systems, it is measured using a CPU counter which is monotonically increased at a frequency related to CPU's hardware clock. The counter resolution is highly dependent on the system's hardware, the value cannot be reliably related to real-world time or even compared between systems in most cases. Furthermore, the counter value is reset every time the CPU is powered up or reset.

time.perf_counter returns the absolute value of the counter. time.process_time is a value which is derived from the CPU counter but updated only when a given process is running on the CPU and can be broken down into 'user time', which is the time when the process itself is running on the CPU, and 'system time', which is the time when the operating system kernel is running on the CPU on behalf on the process.
    
   


bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: bucket[freq].append(num)
        flat_list = list(chain(*bucket))
        return flat_list[::-1][:k]
        

cur = "{}->{}".format(cur, nums[end-1])
ans2 = cur = float('inf')

def myfunc(a):
  return len(a)
x = map(myfunc, ('apple', 'banana', 'cherry'))
print(x)
#convert the map into a list, for readability:
print(list(x))




cd xxx
export Gxxxx_HOST=git.xxx.net
export Gxxxxx_TOKEN=X7xxxxxxxxxxxxTt
export BIxxxxx_HOST=xx-xx.xx-xx.aws
export BIxxxT_TOKEN=NzY0MxxxxJVqxUjXxxxxxxxxxxxx48uE
  python3 -m venv venv
  source venv/bin/activate .
  pip install -r requirements.txt
  pip install --upgrade pip
  pip install argparse

hashtable
points.get(num, 0) if have value, else get 0


        dic=Counter(nums)
        keys=sorted(dic.keys())
