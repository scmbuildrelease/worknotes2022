https://docs.python.org/3.9/library/os.path.html

import csv
def merge_csv(csv_list, output_path):
    # build list with all fieldnames
    fieldnames = list()
    for file in csv_list:
        with open(file, 'r') as input_csv:
            fn = csv.DictReader(input_csv).fieldnames
            fieldnames.extend(x for x in fn if x not in fieldnames)
    # write data to output file based on field names
    with open(output_path, 'w', newline='') as output_csv:
        writer = csv.DictWriter(output_csv, fieldnames=fieldnames)
        writer.writeheader()
        for file in csv_list:
            with open(file, 'r') as input_csv:
                reader = csv.DictReader(input_csv)
                for row in reader:
                    writer.writerow(row)
if __name__ == '__main__':
    merge_csv(['class1.csv', 'class2.csv'], 'all_students.csv')
    
    
    import os
from zipfile import ZipFile
def zip_all(search_dir, extension_list, output_path):
    with ZipFile(output_path, 'w') as output_zip:
        for root, dirs, files in os.walk(search_dir):
            rel_path = os.path.relpath(root, search_dir)
            for file in files:
                name, ext = os.path.splitext(file)
                if ext.lower() in extension_list:
                    output_zip.write(os.path.join(root, file),
                                     arcname=os.path.join(rel_path, file))
if __name__ == '__main__':
    zip_all('.\\my_stuff', ['.jpg','.txt'], 'my_stuff.zip')

    import os
from os.path import join, getsize
for root, dirs, files in os.walk('python/Lib/email'):
    print(root, "consumes", end=" ")
    print(sum(getsize(join(root, name)) for name in files), end=" ")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories
        
        
        
  import os
import re
import urllib.parse
import urllib.request
def download_files(first_url, output_dir):
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)
    url_head, url_tail = os.path.split(first_url)
    first_index = re.findall(r'[0-9]+', url_tail)[-1]
    index_count, error_count = 0, 0
    while(error_count < 5):
        next_index = str(int(first_index) + index_count)
        if first_index[0] == '0': # zero padded
            next_index = '0' * (len(first_index) - len(next_index)) + next_index
        next_url = urllib.parse.urljoin(url_head, re.sub(first_index, next_index, url_tail))
        try:
            output_file = os.path.join(output_dir, os.path.basename(next_url))
            urllib.request.urlretrieve(next_url, output_file)
            print('Successfully downloaded {}'.format(os.path.basename(next_url)))
        except IOError:
            print('Could not retrieve {}'.format(next_url))
            error_count += 1
        index_count += 1        
if __name__ == '__main__':
    download_files('http://123.xx.net/image001.jpg', '.\\images')
    
    
    
    
        
    
    
    
    utf8 = "Hello, World!".encode()
print(utf8)
OUTPUT
b'Hello, World!'
print(utf8.decode())
OUTPUT
Hello, World!

      
      with open(path, encoding='utf-8') as file:
        all_words = re.findall(r"[0-9a-zA-Z-']+", file.read())
        all_words = [word.upper() for word in all_words]
        word_counts = collections.Counter(all_words)
   
   import secrets
def generate_passphrase(num_words):
    with open('diceware.wordlist.asc', 'r') as file:    
        lines = file.readlines()[2:7778]
        word_list = [line.split()[1] for line in lines]
    words = [secrets.choice(word_list) for i in range(num_words)]
    return ' '.join(words)
   
   
   minprice=float("inf")
    for 2. Add Two Numbers, since the sum is the new number ,should create a new node, for remove duplicated node
   since it is already be the node and val, we do not need to create new one and just set the next links.
   
        dummy = ListNode(0,head)
        pred = dummy  
        pred.next = head.next
        return dummy.next
        
        result=ListNode(0)
        res=result
        res.next=ListNode(summ)
        res=res.next
        
   
   forwards = ''.join(re.findall(r'[a-z]+', phrase.lower()))
    backwards = forwards[::-1]
    
    There are two distincts types of 'time', in this context: absolute time and relative time.

Absolute time is the 'real-world time', which is returned by time.time() and which we are all used to deal with. It is usually measured from a fixed point in time in the past (e.g. the UNIX epoch of 00:00:00 UTC on 01/01/1970) at a resolution of at least 1 second. Modern systems usually provide milli- or micro-second resolution. It is maintained by the dedicated hardware on most computers, the RTC (real-time clock) circuit is normally battery powered so the system keeps track of real time between power ups. This 'real-world time' is also subject to modifications based on your location (time-zones) and season (daylight savings) or expressed as an offset from UTC (also known as GMT or Zulu time).

Secondly, there is relative time, which is returned by time.perf_counter and time.process_time. This type of time has no defined relationship to real-world time, in the sense that the relationship is system and implementation specific. It can be used only to measure time intervals, i.e. a unit-less value which is proportional to the time elapsed between two instants. This is mainly used to evaluate relative performance (e.g. whether this version of code runs faster than that version of code).

On modern systems, it is measured using a CPU counter which is monotonically increased at a frequency related to CPU's hardware clock. The counter resolution is highly dependent on the system's hardware, the value cannot be reliably related to real-world time or even compared between systems in most cases. Furthermore, the counter value is reset every time the CPU is powered up or reset.

time.perf_counter returns the absolute value of the counter. time.process_time is a value which is derived from the CPU counter but updated only when a given process is running on the CPU and can be broken down into 'user time', which is the time when the process itself is running on the CPU, and 'system time', which is the time when the operating system kernel is running on the CPU on behalf on the process.
    
   


bucket = [[] for _ in range(len(nums) + 1)]
        Count = Counter(nums).items()  
        for num, freq in Count: bucket[freq].append(num)
        flat_list = list(chain(*bucket))
        return flat_list[::-1][:k]
        

cur = "{}->{}".format(cur, nums[end-1])
ans2 = cur = float('inf')

def myfunc(a):
  return len(a)
x = map(myfunc, ('apple', 'banana', 'cherry'))
print(x)
#convert the map into a list, for readability:
print(list(x))




cd xxx
export Gxxxx_HOST=git.xxx.net
export Gxxxxx_TOKEN=X7xxxxxxxxxxxxTt
export BIxxxxx_HOST=xx-xx.xx-xx.aws
export BIxxxT_TOKEN=NzY0MxxxxJVqxUjXxxxxxxxxxxxx48uE
  python3 -m venv venv
  source venv/bin/activate .
  pip install -r requirements.txt
  pip install --upgrade pip
  pip install argparse

hashtable
points.get(num, 0) if have value, else get 0


        dic=Counter(nums)
        keys=sorted(dic.keys())
